# `BOJ` [`16434`](https://www.acmicpc.net/problem/16434) 드래곤 앤 던전



## 문제

용사는 공주를 구하기 위해 무시무시한 용이 있는 던전으로 향하기로 하였습니다. 우선 용사는 용사 자신과 던전을 분석하였습니다.

용사에게는 세 종류의 능력치가 있습니다. 

- *HMaxHP* : 용사의 최대 생명력입니다. 이 값은 1이상이어야 하며 던전에 들어간 이후로 변하지 않습니다.
- *HCurHP* : 현재 용사의 생명력입니다. 던전에 들어가기 전 이 값은 용사의 최대 생명력 *HMaxHP*와 같습니다. 이 값은 *HMaxHP*보다 커질 수 없습니다.
- *HATK* : 용사의 공격력입니다.

던전은 총 *N*개의 방으로 이루어져 있고 *i*번째 방을 통해서만 *i*+1번째 방으로 이동 할 수 있습니다. 방에는 포션이 있거나 몬스터가 있는데 몬스터가 있을 경우 몬스터를 쓰러트려야지 다음방으로 이동 할 수 있습니다. *N*번째 방에는 공주와 용이 있고, 용을 무찌르면 공주를 구할 수 있습니다.

몬스터가 있는 방에 올 경우 다음과 같이 전투가 진행됩니다.

1. 용사의 공격력 *HATK*만큼 몬스터의 생명력을 깎습니다.
2. 몬스터의 생명력이 0 이하이면 전투가 종료되고 용사는 다음 방으로 이동합니다.
3. 몬스터의 공격력만큼 용사의 생명력 *HCurHP*를 깎습니다.
4. 용사의 생명력이 0 이하이면 전투가 종료되고 용사는 사망합니다.
5. 다시 1부터 진행합니다.

포션이 있는 방에 올 경우 포션을 마셔서 현재 용사의 생명력 *HCurHP*가 일정량 회복되고 공격력 *HATK*도 일정량만큼 증가됩니다. 회복된 생명력이 최대 생명력 *HMaxHP*보다 큰 경우 용사의 현재 생명력 *HCurHP*가 최대 생명력 *HMaxHP*와 같아집니다.

용사는 던전으로 향하기 전에 만반의 준비를 하고 있습니다. 용사는 수련을 하면 최대 생명력 *HMaxHP*를 늘릴 수 있는데 얼마나 수련해야 할지 고민입니다.

용사는 *N*번 방에 있는 용을 쓰러트리기 위한 최소의 *HMaxHP*를 여러분이 계산해주면 좋겠다고 합니다.



## 코드

```cpp
#include <iostream>
#include <limits.h>
#include <vector>

using namespace std;

int n;
long long ATK;
vector <pair<int, pair<int, int>>> v;

bool game(long long HP) {
   long long atk = ATK;
   long long hp = HP;
   int enermy_atk, enermy_hp;
   long long val;
   int len = v.size();
   for (int i = 0; i < len; i++) {
      if (v[i].first == 1) {
         enermy_atk = v[i].second.first;
         enermy_hp = v[i].second.second;
         
         if (enermy_hp % atk)
            val = enermy_hp / atk + 1;
         else
            val = enermy_hp / atk;
         hp -= enermy_atk * (val - 1);
         if (hp <= 0)
            return false;
         /*if (enermy_hp / atk > hp / enermy_atk)
            return false;
         if(enermy_hp % atk)
            hp -= (enermy_hp / atk) * enermy_atk;
         else 
            hp -= (enermy_hp / atk) * enermy_atk;*/
         /*if ((enermy_hp - 1) / atk > (hp - 1) / enermy_atk)
            return false;
         hp -= (enermy_hp - 1) / atk * enermy_atk;*/
      }
      else {
         atk += v[i].second.first;
         if (hp + v[i].second.second >= HP)
            hp = HP;
         else
            hp += v[i].second.second;
      }
   }
   return true;
}

int main() {
   ios_base::sync_with_stdio(false);
   cin.tie(NULL);
   int t, a, h;
   long long start, mid, last, res;

   cin >> n >> ATK;
   for (int i = 0; i < n; i++) {
      cin >> t >> a >> h;
      v.push_back(make_pair(t, make_pair(a, h)));
   }
   start = 1;
   last = LLONG_MAX;
   while (start <= last) {
      mid = (start >> 1) + (last >> 1);
      if (game(mid)) {
         last = mid - 1;
         res = mid;
      }
      else
         start = mid + 1;
   }
   cout << res << '\n';
   return 0;
}
```


